# 1. useState 대신 useRef
<<<<<<< HEAD
### useState와 useRef의 기본적인 차이
* useState는 state 값과 그 값을 갱신하는 함수를 제공합니다. 값이 변경되면 컴포넌트가 리렌더링됩니다.
* useRef는 변경 가능한 참조값을 제공하며, 값이 변경되어도 리렌더링이 발생하지 않습니다.
### useRef의 유용한 사용 사례
* 컴포넌트의 전체 수명주기 동안 지속되어야 하는 값을 관리할 때 (예: isMount 플래그)
* 렌더링 프로세스와 관계없이 가변적으로 값을 저장해야 할 때
### isMount 상태 관리의 문제점
* useState로 isMount 상태를 관리하면 불필요한 리렌더링이 발생합니다.
* 리액트 개발진은 isMount와 같은 상태를 만들지 말 것을 권장합니다.
### useRef를 통한 isMount 상태 관리
* useRef를 사용하면 불필요한 리렌더링 없이 isMount 상태를 관리할 수 있습니다.
* useRef는 DOM에만 붙일 수 있는 API가 아니라 일반적인 가변 컨테이너로도 사용할 수 있습니다.

**=> UseRef를 통해 불필요한 리렌더링 방지 가능!**   
**=> 컴포넌트 전체 수명주기와 동일한 값을 제공해야 할 때는 UseRef 고려하기!**
  

# 2. 연관된 상태 단순화 하기(Keep It Simple, Stupid)
### 상태 관리의 복잡성
* 예제 코드에서 loading, finish, error 상태가 서로 연관되어 있음
* 여러 상태를 동기화하며 관리하기 어렵고, 실수할 가능성이 있음
### 열거형(enum) 타입을 활용한 단일 상태 관리
* 연관된 상태들을 하나의 상태로 합치는 방법 제시
* 열거형 타입(JS의 객체 리터럴)을 정의하여 가능한 상태 값들을 명시적으로 제한
* 단일 상태와 열거형 값만으로 상태 관리 가능
### KISS 원칙 적용
* 복잡한 객체 대신 간단한 문자열 타입으로 상태 표현
* 상태 동기화 로직이 단순해지고 가독성이 향상됨
### 상태 관리 모범 사례
* Promise의 pending, fulfilled, rejected 상태를 참고하여 상태 설계
* 연관된 상태들을 하나로 합쳐서 관리하면 상태 폭증과 부작용을 방지할 수 있음
=======

### useState와 useRef의 기본적인 차이

- useState는 state 값과 그 값을 갱신하는 함수를 제공합니다. 값이 변경되면 컴포넌트가 리렌더링됩니다.
- useRef는 변경 가능한 참조값을 제공하며, 값이 변경되어도 리렌더링이 발생하지 않습니다.

### useRef의 유용한 사용 사례

- 컴포넌트의 전체 수명주기 동안 지속되어야 하는 값을 관리할 때 (예: isMount 플래그)
- 렌더링 프로세스와 관계없이 가변적으로 값을 저장해야 할 때

### isMount 상태 관리의 문제점

- useState로 isMount 상태를 관리하면 불필요한 리렌더링이 발생합니다.
- 리액트 개발진은 isMount와 같은 상태를 만들지 말 것을 권장합니다.

### useRef를 통한 isMount 상태 관리

- useRef를 사용하면 불필요한 리렌더링 없이 isMount 상태를 관리할 수 있습니다.
- useRef는 DOM에만 붙일 수 있는 API가 아니라 일반적인 가변 컨테이너로도 사용할 수 있습니다.

**=> UseRef를 통해 불필요한 리렌더링 방지 가능!**  
**=> 컴포넌트 전체 수명주기와 동일한 값을 제공해야 할 때는 UseRef 고려하기!**

# 2. 연관된 상태 단순화 하기(Keep It Simple, Stupid)

### 상태 관리의 복잡성

- 예제 코드에서 loading, finish, error 상태가 서로 연관되어 있음
- 여러 상태를 동기화하며 관리하기 어렵고, 실수할 가능성이 있음

### 열거형(enum) 타입을 활용한 단일 상태 관리

- 연관된 상태들을 하나의 상태로 합치는 방법 제시
- 열거형 타입(JS의 객체 리터럴)을 정의하여 가능한 상태 값들을 명시적으로 제한
- 단일 상태와 열거형 값만으로 상태 관리 가능

### KISS 원칙 적용

- 복잡한 객체 대신 간단한 문자열 타입으로 상태 표현
- 상태 동기화 로직이 단순해지고 가독성이 향상됨

### 상태 관리 모범 사례

- Promise의 pending, fulfilled, rejected 상태를 참고하여 상태 설계
- 연관된 상태들을 하나로 합쳐서 관리하면 상태 폭증과 부작용을 방지할 수 있음
>>>>>>> 85be19bf201706c40c2c55224909d10a3f483246

**=> KISS 원칙을 따르고, 적절한 데이터 구조(객체, 문자열 등)를 활용하는 것이 중요!**

# 3. 연관된 상태 객체로 묶어내기
<<<<<<< HEAD
### 연관된 상태 관리의 어려움
* 예제에서 isLoading, isSuccess, isFail 상태가 서로 연관되어 있음
* 하나의 상태가 변경되면 나머지 상태들도 동기화해야 하는 문제
### 객체를 활용한 상태 관리
* 연관된 상태들을 하나의 객체로 묶어 단일 상태로 관리
* 상태 업데이트 시 spread 연산자를 통해 기존 상태를 참조하여 특정 필드만 변경
### 장점
* 상태 동기화 로직이 간소화되고 명시적임
* 상태 값을 한눈에 파악하기 쉬움
* 선언형 프로그래밍 스타일에 가까워짐
### 상태 관리 유연성
* 하나의 상태가 반드시 하나의 useState로 표현될 필요는 없음
* 상황에 따라 여러 상태를 하나의 객체로 묶어 관리할 수 있음
=======

### 연관된 상태 관리의 어려움

- 예제에서 isLoading, isSuccess, isFail 상태가 서로 연관되어 있음
- 하나의 상태가 변경되면 나머지 상태들도 동기화해야 하는 문제

### 객체를 활용한 상태 관리

- 연관된 상태들을 하나의 객체로 묶어 단일 상태로 관리
- 상태 업데이트 시 spread 연산자를 통해 기존 상태를 참조하여 특정 필드만 변경

### 장점

- 상태 동기화 로직이 간소화되고 명시적임
- 상태 값을 한눈에 파악하기 쉬움
- 선언형 프로그래밍 스타일에 가까워짐

### 상태 관리 유연성

- 하나의 상태가 반드시 하나의 useState로 표현될 필요는 없음
- 상황에 따라 여러 상태를 하나의 객체로 묶어 관리할 수 있음
>>>>>>> 85be19bf201706c40c2c55224909d10a3f483246

**=> 불필요한 상태 분리를 지양하고, 상태 간 관계를 고려해 적절히 묶는 것이 중요!**

# 4. useState에서 useReducer로 리팩터링
<<<<<<< HEAD
### useReducer 소개
* useState와 유사하지만 상태 업데이트 로직을 분리할 수 있음
* reducer 함수와 초기 상태를 인자로 받음
### useReducer의 장점
* 상태 업데이트 로직을 reducer 함수로 추상화할 수 있음
* 복잡한 상태 로직을 구조화하여 관리할 수 있음
* React에 의존적이지 않은 순수 JavaScript 문법
### 리팩터링 과정
* 초기 상태 객체 정의
* reducer 함수 작성 (switch-case 또는 if 문 활용)
* action type 정의 및 dispatch 호출
### reducer 활용 팁
* 액션 타입을 상수로 정의하여 오타 방지 및 가독성 향상
* 상태 업데이트 시 기존 상태를 spread 연산자로 참조하여 불변성 유지
### useReducer의 추가 장점
* 상태 업데이트 로직을 컴포넌트 외부에 분리하여 재사용성 향상
* 상태 관리 로직을 직관적으로 파악 가능

# 5. 상태 로직 Custom Hooks 로 뽑아내기
### 상태 관리 로직 추출의 필요성
* 컴포넌트의 렌더링 로직과 상태 관리 로직을 분리하여 코드 가독성 향상
* 상태 관리 로직을 재사용 가능한 형태로 만들기
### 커스텀 훅 생성
* use Prefix를 사용하여 커스텀 훅 작성 (예: useFetchData)
* 상태 관리 로직을 커스텀 훅 내부에 작성
### 커스텀 훅 사용
* 렌더링 컴포넌트에서 커스텀 훅을 호출하여 상태와 상태 업데이트 함수 받아오기
* 상태 및 효과 로직을 커스텀 훅 내부에서 관리
### 커스텀 훅 반환 값
* 객체, 배열 등 다양한 형태로 반환 가능
* 상황에 맞게 유연하게 반환 값 구성 가능
### 장점
* 상태 관리 로직의 재사용성 향상
* 컴포넌트 코드의 가독성 및 유지보수성 향상
* 로직을 분리하여 개별 테스트 가능

# 6. 이전 상태 활용하기
### 상태 업데이트 방식 비교
* 직접 상태 값을 할당하는 방식
* 이전 상태를 참조하여 업데이트하는 방식(updater function)
### 이전 상태 참조 방식의 장점
* setState가 비동기적으로 처리되므로 이전 상태 값을 정확히 참조할 수 있음
* 예상치 못한 상태 변화를 방지할 수 있음
### 이전 상태 미참조 시 발생 가능한 문제
* 연관된 상태들이 예상과 다르게 업데이트될 수 있음
* 특히 모달 팝업, 입력 폼 등에서 에러가 발생할 가능성이 높음
### 상태 업데이트 원칙
* 대부분의 경우 updater function을 활용하여 이전 상태를 참조하는 것이 안전함
* 상태를 완전히 덮어쓰고자 할 때만 직접 값을 할당하는 방식 사용
=======

### useReducer 소개

- useState와 유사하지만 상태 업데이트 로직을 분리할 수 있음
- reducer 함수와 초기 상태를 인자로 받음

### useReducer의 장점

- 상태 업데이트 로직을 reducer 함수로 추상화할 수 있음
- 복잡한 상태 로직을 구조화하여 관리할 수 있음
- React에 의존적이지 않은 순수 JavaScript 문법

### 리팩터링 과정

- 초기 상태 객체 정의
- reducer 함수 작성 (switch-case 또는 if 문 활용)
- action type 정의 및 dispatch 호출

### reducer 활용 팁

- 액션 타입을 상수로 정의하여 오타 방지 및 가독성 향상
- 상태 업데이트 시 기존 상태를 spread 연산자로 참조하여 불변성 유지

### useReducer의 추가 장점

- 상태 업데이트 로직을 컴포넌트 외부에 분리하여 재사용성 향상
- 상태 관리 로직을 직관적으로 파악 가능

# 5. 상태 로직 Custom Hooks 로 뽑아내기

### 상태 관리 로직 추출의 필요성

- 컴포넌트의 렌더링 로직과 상태 관리 로직을 분리하여 코드 가독성 향상
- 상태 관리 로직을 재사용 가능한 형태로 만들기

### 커스텀 훅 생성

- use Prefix를 사용하여 커스텀 훅 작성 (예: useFetchData)
- 상태 관리 로직을 커스텀 훅 내부에 작성

### 커스텀 훅 사용

- 렌더링 컴포넌트에서 커스텀 훅을 호출하여 상태와 상태 업데이트 함수 받아오기
- 상태 및 효과 로직을 커스텀 훅 내부에서 관리

### 커스텀 훅 반환 값

- 객체, 배열 등 다양한 형태로 반환 가능
- 상황에 맞게 유연하게 반환 값 구성 가능

### 장점

- 상태 관리 로직의 재사용성 향상
- 컴포넌트 코드의 가독성 및 유지보수성 향상
- 로직을 분리하여 개별 테스트 가능

# 6. 이전 상태 활용하기

### 상태 업데이트 방식 비교

- 직접 상태 값을 할당하는 방식
- 이전 상태를 참조하여 업데이트하는 방식(updater function)

### 이전 상태 참조 방식의 장점

- setState가 비동기적으로 처리되므로 이전 상태 값을 정확히 참조할 수 있음
- 예상치 못한 상태 변화를 방지할 수 있음

### 이전 상태 미참조 시 발생 가능한 문제

- 연관된 상태들이 예상과 다르게 업데이트될 수 있음
- 특히 모달 팝업, 입력 폼 등에서 에러가 발생할 가능성이 높음

### 상태 업데이트 원칙

- 대부분의 경우 updater function을 활용하여 이전 상태를 참조하는 것이 안전함
- 상태를 완전히 덮어쓰고자 할 때만 직접 값을 할당하는 방식 사용
>>>>>>> 85be19bf201706c40c2c55224909d10a3f483246
