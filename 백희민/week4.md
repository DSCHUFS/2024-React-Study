# 1. CSS in JS 인라인 스타일 지양하기

```
const cardCss = {
    self: css`
        background-color: white;
        border: 1px solid #eee;
        border-ratius: 0.5rem;
        padding: 1rem;
    `,

    title: css`
        font-size: 1.25rem;
    `
}
```
* CSS 문자열로 사용을 했을 때 타입 안정성 없음.
* 편집기에서 자동추론 및 자동완성이 불가능하여 안정성이 없음
* 개발자 경험에 좋지 않음
* 즉 DX에도 좋지 않고 버그가 생길 수도 있다!

```
const cardCss = {
    self: css({
        backgroundColor: 'white';
        border: '1px solid #eee';
        borderRatius: '0.5rem';
        padding: '1rem';
    }),

    title: css({
        font-size: 1.25rem;
    })
}
```
* 자동완성, 타입 추론, DX, 안정성 모든 걸 챙길 수 있음.

### CSS in JS 인라인 스타일 지양하기의 장점

* 외부로 분리했기 때문에 이제 스타일 렌더링 될때마다 직렬화되지 않는다 => 한번만 된다.
* 동적인 스타일을 실수로 건드는 확률이 적어진다.
* 스타일 관련 코드를 분리해서 로직에 집중하고 JSX를 볼때 좀 더 간결하게 볼 수 있다.

### 타입 안정성

* 자동완성으로 생산성 DX
* export, 내부에서만 사용할 수도 있을때?
* export 하는 경우 외부의 컴포넌트에서도 사용할 수 있다.

### CSS in JS 인라인 스타일을 지양해야 하는 이유
**=> 성능저하를 일으킴
**=> 휴먼 에러가 발생할 수 있음
**=> export 할 수 없음


# 2. 객체 Props 지양하기

```
Object.is(
    { hello: "world" },  // 초기 렌더링
    { hello: "world" }   // 두번째 렌더링
)
```
* 우리 눈으로 보기엔 같은 key와 value지만, 결과는 false

### 해결책
* 변하지 않는 값일 경우 컴포넌트 외부로 드러내기
* 필요한 값만 객체를 분해해서 Props로 내려준다.
* 정말 값비싼 연산, 너무 잦은 연산이 있을 경우 useMemo() 활용하여 계산된 값을 메모이제이션한다.
* 컴포넌트를 더 평탄하게 나누면 나눌 Props 또한 평탄하게 나눠서 내릴 수 있다.


# 3. HTML Attribute 주의하기
* HTML의 속성은 Attribute, 자바스크립트의 속성은 Property로 불리며, 이 둘은 혼동하기 쉬움.

# 예약어의 중요성: 
* HTML과 자바스크립트에는 각각 예약어가 있음. 
* HTML에서는 class나 input의 type과 같은 속성

# 커스텀 컴포넌트에서의 속성 관리
* HTML Attribute와의 중복을 피하기 위해 props를 선언

# 타입스크립트를 활용한 속성 관리
* 타입스크립트를 사용하면 HTML attribute와 충돌할 수 있는 속성을 사전에 확인하고 방지할 수 있음
* rest 파라미터를 사용하여 HTML attribute와의 충돌을 피할 수 있음.

# 4. ..props 주의할 점

### Spread Operator를 통한 Props 전달:
* Spread Operator는 부모 컴포넌트에서 하위 컴포넌트로 Props를 전달하는 데 많이 활용됨. 

### Props 관리의 어려움: 
* Spread Operator를 사용하여 Props를 전달하면 코드의 예측성이 떨어질 수 있음. 
* 특히 Props가 계층적으로 전달될 경우, 해당 Props를 추적하기 어려움. 
* 이러한 현상은 Props Drilling이나 렌더링 문제를 야기할 수 있음.

### Props 관리를 위한 해결책: 
* Props를 효율적으로 관리하기 위해서는 Spread Operator를 적절히 활용해야함.
* 예측하기 어려운 Props는 최소화하고, 필요한 Props만 명시적으로 전달해야함.

### 고차 컴포넌트(Higher Order Component) 패턴 활용: 
* Props 관리에 어려움을 겪을 때는 고차 컴포넌트 패턴을 활용할 수 있음. 
* 이를 통해 관련 없는 Props를 필터링하고 필요한 Props만 하위 컴포넌트로 전달할 수 있음.

### 클래스 컴포넌트에서의 적용: 
Spread Operator를 활용한 Props 관리는 함수형 컴포넌트뿐만 아니라 클래스 컴포넌트에서도 유용하게 적용될 수 있음.
* 클래스 컴포넌트에서도 Props를 명시적으로 관리하여 코드의 가독성과 유지보수성을 향상시킬 수 있음.

**=> props에서 spread 연산자가 쓰이면 관련 있는 props, 없는 props, 나머지 props로 나눠보자

# 5. 많은 Props 일단 분리하기
### 너무 많은 Props 처리: 
* 프로젝트에서 Props가 많아질 때, 이를 관리하기 위해 다양한 상태 관리 라이브러리나 패턴을 도입하는 경향이 있음. 
* 그러나 결과나 패턴에 집착하기보다 실행에 집중하는 것이 중요.

### 간단한 분리: 
* 너무 많은 Props를 처리할 때는 먼저 간단한 분리를 시도해보는 것이 좋음. 
* 예를 들어, 회원가입 폼에서 유저 정보, 인증 정보, 위치 정보, 취향 정보 등을 별도의 하위 컴포넌트로 분리하여 구조화할 수 있음.

### 도메인 로직 분리: 
* 분리된 컴포넌트에서 도메인 로직을 분리하여 관리할 수 있음. 
* 이를 통해 폼 데이터를 처리하는 로직을 개별적으로 관리할 수 있으며, 이를 context API나 hook을 활용하여 구현할 수 있음.

### 폼 데이터 관리: 
* 분리된 컴포넌트에서는 폼 데이터만을 다루도록 Props를 변경하여 가독성을 높일 수 있음. 
* 이를 통해 코드의 구조화와 확장성을 향상시킬 수 있음.




# 6. 객체보다는 단순한 Props의 장점
### 불필요한 Props: 
* 객체를 통째로 받는 경우, 필요한 데이터만을 가져오기 어렵고 불필요한 Props가 전달될 수 있음. -> 컴포넌트의 불필요한 렌더링을 유발

### 수명 주기 문제: 
* 객체가 다시 생성될 때마다 하위 컴포넌트가 불필요하게 다시 렌더링될 수 있음. -> 성능 저하

### 메모화의 한계: 
* memo를 사용하여 최적화를 시도해도, 불필요한 Props를 전달하는 경우 성능 최적화에 한계가 있을 수 있음.

### Props 분해: 
* 부모 컴포넌트에서 불필요한 Props를 제거하고 필요한 데이터만을 분해하여 내려주는 것이 좋음. 
* 이를 통해 Props가 더 명확해지고 불필요한 렌더링을 줄일 수 있음.

### 성능 최적화: 
* 분해된 Props를 사용하여 memo 등을 통해 성능 최적화를 더욱 효과적으로 할 수 있음.